package dominator

import "github.com/nukilabs/decompile/graph"

// Tree represents the dominator tree of a directed graph.
type Tree[N comparable] struct {
	root        *graph.Node[N]
	dominatorOf map[graph.ID[N]]*graph.Node[N]
	dominatedBy map[graph.ID[N]][]*graph.Node[N]
}

// Root returns the entry (root) node of the dominator tree.
func (dt *Tree[N]) Root() *graph.Node[N] {
	return dt.root
}

// DominatorOf returns the immediate dominator of node n.
func (dt *Tree[N]) DominatorOf(n *graph.Node[N]) *graph.Node[N] {
	return dt.dominatorOf[n.ID()]
}

// DominatedBy returns the list of nodes immediately dominated by n.
func (dt *Tree[N]) DominatedBy(n *graph.Node[N]) []*graph.Node[N] {
	return dt.dominatedBy[n.ID()]
}

// Dominates returns true if node a dominates node b.
func (dt *Tree[N]) Dominates(a, b *graph.Node[N]) bool {
	dom := dt.DominatorOf(b)
	return dom != nil && dom.ID() == a.ID()
}

// New computes the dominator tree for all nodes in the graph
// using the Lengauerâ€“Tarjan algorithm. The graph's own root (graph.root) is used.
func New[N comparable](g *graph.Graph[N]) *Tree[N] {
	lt := lengauerTarjan[N]{
		indexOf: make(map[graph.ID[N]]int),
	}

	// step 1.
	lt.dfs(g, g.Root())

	for i := len(lt.nodes) - 1; i > 0; i-- {
		w := lt.nodes[i]

		// step 2.
		for _, v := range w.pred {
			u := lt.eval(v)

			if u.semi < w.semi {
				w.semi = u.semi
			}
		}

		lt.nodes[w.semi].bucket[w] = struct{}{}
		lt.link(w.parent, w)

		// step 3.
		for v := range w.parent.bucket {
			delete(w.parent.bucket, v)

			u := lt.eval(v)
			if u.semi < v.semi {
				v.dom = u
			} else {
				v.dom = w.parent
			}
		}
	}

	// step 4.
	for _, w := range lt.nodes[1:] {
		if w.dom.node.ID() != lt.nodes[w.semi].node.ID() {
			w.dom = w.dom.dom
		}
	}

	// Construct the public-facing dominator tree structure.
	dominatorOf := make(map[graph.ID[N]]*graph.Node[N])
	dominatedBy := make(map[graph.ID[N]][]*graph.Node[N])
	for _, w := range lt.nodes[1:] {
		dominatorOf[w.node.ID()] = w.dom.node
		did := w.dom.node.ID()
		dominatedBy[did] = append(dominatedBy[did], w.node)
	}
	return &Tree[N]{
		root:        g.Root(),
		dominatorOf: dominatorOf,
		dominatedBy: dominatedBy,
	}
}

// lengauerTarjan holds global state of the Lengauer-Tarjan algorithm.
// This is a mapping between nodes and the postordering of the nodes.
type lengauerTarjan[N comparable] struct {
	// nodes is the nodes traversed during the
	// Lengauer-Tarjan depth-first-search.
	nodes []*ltNode[N]
	// indexOf contains a mapping between
	// the id-dense representation of the
	// graph and the potentially id-sparse
	// nodes held in nodes.
	//
	// This corresponds to the vertex
	// number of the node in the Lengauer-
	// Tarjan algorithm.
	indexOf map[graph.ID[N]]int
}

// ltNode is a graph node with accounting for the Lengauer-Tarjan
// algorithm.
//
// For the purposes of documentation the ltNode is given the name w.
type ltNode[N comparable] struct {
	node *graph.Node[N]

	// parent is vertex which is the parent of w
	// in the spanning tree generated by the search.
	parent *ltNode[N]

	// pred is the set of vertices v such that (v, w)
	// is an edge of the graph.
	pred []*ltNode[N]

	// semi is a number defined as follows:
	// (i)  After w is numbered but before its semidominator
	//      is computed, semi is the number of w.
	// (ii) After the semidominator of w is computed, semi
	//      is the number of the semidominator of w.
	semi int

	// bucket is the set of vertices whose
	// semidominator is w.
	bucket map[*ltNode[N]]struct{}

	// dom is vertex defined as follows:
	// (i)  After step 3, if the semidominator of w is its
	//      immediate dominator, then dom is the immediate
	//      dominator of w. Otherwise dom is a vertex v
	//      whose number is smaller than w and whose immediate
	//      dominator is also w's immediate dominator.
	// (ii) After step 4, dom is the immediate dominator of w.
	dom *ltNode[N]

	// In general ancestor is nil only if w is a tree root
	// in the forest; otherwise ancestor is an ancestor
	// of w in the forest.
	ancestor *ltNode[N]

	// Initially label is w. It is adjusted during
	// the algorithm to maintain invariant (3) in the
	// Lengauer and Tarjan paper.
	label *ltNode[N]
}

// dfs is the Lengauer-Tarjan DFS procedure.
func (lt *lengauerTarjan[N]) dfs(g *graph.Graph[N], v *graph.Node[N]) {
	i := len(lt.nodes)
	lt.indexOf[v.ID()] = i
	ltv := &ltNode[N]{
		node:   v,
		semi:   i,
		bucket: make(map[*ltNode[N]]struct{}),
	}
	ltv.label = ltv
	lt.nodes = append(lt.nodes, ltv)

	for _, w := range g.Successors(v) {
		wid := w.ID()
		idx, ok := lt.indexOf[wid]
		if !ok {
			lt.dfs(g, w)

			// We place this below the recursive call
			// in contrast to the original algorithm
			// since w needs to be initialised, and
			// this happens in the child call to dfs.
			idx, ok = lt.indexOf[wid]
			if !ok {
				panic("path: unintialized node")
			}
			lt.nodes[idx].parent = ltv
		}
		ltw := lt.nodes[idx]
		ltw.pred = append(ltw.pred, ltv)
	}
}

// compress is the Lengauer-Tarjan COMPRESS procedure.
func (lt *lengauerTarjan[N]) compress(v *ltNode[N]) {
	if v.ancestor.ancestor != nil {
		lt.compress(v.ancestor)
		if v.ancestor.label.semi < v.label.semi {
			v.label = v.ancestor.label
		}
		v.ancestor = v.ancestor.ancestor
	}
}

// eval is the Lengauer-Tarjan EVAL function.
func (lt *lengauerTarjan[N]) eval(v *ltNode[N]) *ltNode[N] {
	if v.ancestor == nil {
		return v
	}
	lt.compress(v)
	return v.label
}

// link is the Lengauer-Tarjan LINK procedure.
func (*lengauerTarjan[N]) link(v, w *ltNode[N]) {
	w.ancestor = v
}
